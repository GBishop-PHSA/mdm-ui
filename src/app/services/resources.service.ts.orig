import { Injectable } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import "rxjs-compat/add/operator/map";
import { ValidatorService } from "./validator.service";
import { RestHandlerService } from "./utility/rest-handler.service";

@Injectable({
    providedIn: 'root'
})
export class ResourcesService {
    private subject = new Subject<any>();
    Folderdetails = new Subject<any>();
    FolderPermissions = new Subject<any>();

    constructor(private http: HttpClient, private validator: ValidatorService, private restHandler: RestHandlerService) { }

    SearchResult: any[];

    API = 'http://localhost:8080/api';

    HistoryGet(id: string, queryString: string): Observable<any> {
        return this.http.get<any>(this.API + '/folders/a61e88e7-c951-4624-baaf-ec03cd09357b/edits?offset=0&max=20');
    }

    get(name, id, action, options?): any {
        if (!options) {
            options = {};
        }
        if (name && name[name.length - 1] == '/') {
            name = name.substr(0, name.length - 1);
        }

        if (options.filters && options.filters[options.filters.length - 1] === '&') {
            options.filters = options.filters.substr(0, options.filters.length - 1);
        }
        if (options.filters && options.filters[options.filters.length - 1] === '&') {
            options.filters = options.filters.substr(1, options.filters.length);
        }

        id = !id ? "" : id + "/";
        action = !action ? "" : action;
        var pagination = !options.pageSize ? "" : "offset=" + options.pageIndex + "&max=" + options.pageSize;
        var sort = !options.sortBy ? "" : "&sort=" + options.sortBy + "&order=" + (!options.sortType ? "asc" : options.sortType);
        var filters = !options.filters ? "" : "&" + options.filters;
        var all = !options.all ? "" : "&all=true";
        var qStr = "";

        if (options.queryStringParams) {
            for (var n in options.queryStringParams) {
                if (options.queryStringParams.hasOwnProperty(n)) {
                    if (!this.validator.isEmpty(options.queryStringParams[n])) {
                        qStr += "&" + n + "=" + options.queryStringParams[n];
                    }
                }
            }
        }

        if (pagination || sort || filters || all || qStr) {
            pagination = "?" + pagination;
        }

        return this.request(name + "/" + id + action + pagination + sort + filters + all + qStr, "GET", options.resource, options.contentType);
    }

    post(name, id, action, options, more?): any {
        if (!options) {
            options = {};
        }
        if (name && name[name.length - 1] === '/') {
            name = name.substr(0, name.length - 1);
        }
        id = !id ? "" : id + "/";
        action = !action ? "" : action;
        var pagination = !options.pageSize ? "" : "offset=" + options.pageIndex + "&max=" + options.pageSize;
        var sort = !options.sortBy ? "" : "&sort=" + options.sortBy + "&order=" + (!options.sortType ? "asc" : options.sortType);
        var filters = !options.filters ? "" : "&" + options.filters;
        var qStr = "";

        if (options.queryStringParams) {
            for (var n in options.queryStringParams) {
                if (options.queryStringParams.hasOwnProperty(n)) {
                    if (!this.validator.isEmpty(options.queryStringParams[n])) {
                        qStr += "&" + n + "=" + options.queryStringParams[n];
                    }
                }
            }
        }
        if (pagination || sort || filters || qStr) {
            pagination = "?" + pagination;
        }
        return this.request(name + "/" + id + action + pagination + sort + filters + qStr, "POST", options.resource, options.contentType, more);
    }

    put(name, id, action, options) {
        if (!options) {
            options = {};
        }
        if (name && name[name.length - 1] == '/') {
            name = name.substr(0, name.length - 1);
        }
        id = !id ? "" : id + "/";
        action = !action ? "" : action;
        var pagination = !options.pageSize ? "" : "offset=" + options.pageIndex + "&max=" + options.pageSize;
        var sort = !options.sortBy ? "" : "&sort=" + options.sortBy + "&order=" + (!options.sortType ? "asc" : options.sortType);
        var filters = !options.filters ? "" : "&" + options.filters;
        var qStr = "";

        if (options.queryStringParams) {
            for (var n in options.queryStringParams) {
                if (options.queryStringParams.hasOwnProperty(n)) {
                    if (!this.validator.isEmpty(options.queryStringParams[n])) {
                        qStr += "&" + n + "=" + options.queryStringParams[n];
                    }
                }
            }
        }

        if (pagination || sort || filters || qStr) {
            pagination = "?" + pagination;
        }
        return this.request(name + "/" + id + action + pagination + sort + filters + qStr, "PUT", options.resource, options.contentType);
    }

<<<<<<< HEAD
    delete(name, id, action, queryString, resource) {
=======
    delete(name, id, action?, queryString?, resource?)
    {
>>>>>>> 11d723a64f4499b439bd6ed5521ca4c4101a0749
        if (name && name[name.length - 1] === '/') {
            name = name.substr(0, name.length - 1);
        }
        id = !id ? "" : id + "/";
        action = !action ? "" : action;
        queryString = !queryString ? "" : ("?" + queryString);

        return this.request(name + "/" + id + action + queryString, "DELETE", resource, null);
    }

    request(url, HTTP, resource, contentType, more?): any {
        if (url && url[0] == '/') {
            url = url.substr(1);
        }
        var options = {
            url: this.API + '/' + url,
            method: HTTP,
            data: null,
            login: false,
            ignoreAuthModule: false,
            withCredentials: true,
            headers: {
                'Content-Type': contentType ? contentType : 'application/json; charset=utf-8'
            }
        };
        if (resource) {
            options.data = resource;
        }
        if (more && more.login == true) {
            options.login = true;
        }
        if (more && more.ignoreAuthModule == true) {
            options.ignoreAuthModule = true;
        }
        if (more && more.withCredentials == true) {
            options.withCredentials = true;
        }

        return this.restHandler.restHandler(options);
    }

    catalogueItemOld: any = {
        tree: function (id, includeSupersededModels) {
            id = id ? "?id=" + id : "";
            includeSupersededModels = includeSupersededModels ? "?includeSupersededModels=true" : "";
            return this.request("catalogueItems/tree" + id + includeSupersededModels, "GET");
        },
        get: function (id, action, options) {
            return this.get("catalogueItems", id, action, options);
        },
        post: function (id, action, options) {
            return this.post("catalogueItems", id, action, options);
        },
        put: function (id, action, childId, options) {
            if (!options) {
                options = {};
            }
            id = !id ? "" : id;
            action = !action ? "" : action + "/";
            childId = !childId ? "" : childId;
            return this.put("catalogueItems", id, action + childId, options);
        },
        delete: function (id, action, childId) {
            id = !id ? "" : id;
            action = !action ? "" : action + "/";
            childId = !childId ? "" : childId;
            return this.httpDelete("catalogueItems", id, action + childId);
        }
    }

    dataClass: any = {
        post: function (dataModelId, id, action, options) {
            return this.post("dataModels/" + dataModelId + "/dataClasses/", id, action, options);
        }
    }

    classifier: Classifier = new Classifier(this);
    terminology: Terminology = new Terminology(this);
    term: Term = new Term(this);
    folder: Folder = new Folder(this);
    catalogueUser: CatalogueUser = new CatalogueUser(this);
    catalogueItem: CatalogueItem = new CatalogueItem(this);
    userGroup: UserGroup = new UserGroup(this);
    authentication: Authentication = new Authentication(this);
    tree: Tree = new Tree(this);
    metadata: MetaData = new MetaData(this);
    facets: Facets = new Facets(this);
    dataModel: DataModel = new DataModel(this);
}

class Classifier {
    constructor(private resourcesService: ResourcesService) { }

    get(id, action, options) {
        return this.resourcesService.get("classifiers", id, action, options);
    }
}

class Folder {
    constructor(private resourcesService: ResourcesService) { }
    get(id, action, options?) {
        if (!options) {
            options = {};
        }

        return this.resourcesService.get("folders", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("folders", id, action, options);
    }
    put(id, action, options) {
        return this.resourcesService.put("folders", id, action, options);
    }
    delete(id, action, queryString) {
        return this.resourcesService.delete("folders", id, action, queryString, null);
    }
}

class Terminology {
    constructor(private resourcesService: ResourcesService) { }
<<<<<<< HEAD
    get(id, action, options) {
=======
    get(id, action, options: any = {})
    {
>>>>>>> 11d723a64f4499b439bd6ed5521ca4c4101a0749
        if (!options) {
            options = {};
        }
        if (['metadata', 'annotations', 'classifiers', 'semanticLinks'].indexOf(action) !== -1) {
            return this.resourcesService.catalogueItem.get(id, action, options.contentType);
        }
        return this.resourcesService.get("terminologies", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("terminologies", id, action, options);
    }

    put(id, action, options) {
        return this.resourcesService.put("terminologies", id, action, options);
    }
}

<<<<<<< HEAD
class CatalogueUser {
=======
class Term
{
    constructor(private resourcesService: ResourcesService) { }
    
    get(terminologyId, id, action, options: any = {}) {
        if(['metadata', 'annotations', 'classifiers'].indexOf(action) !== -1){
            return this.resourcesService.catalogueItem.get(id, action, options.contentType);
        }

        return this.resourcesService.get("terminologies/" + terminologyId + "/terms/" , id, action, options);
    }

    put(terminologyId, id, action, options) {
        return this.resourcesService.put("terminologies/" + terminologyId + "/terms/" , id, action, options);
    }

    post(terminologyId, id, action, options) {
        return this.resourcesService.post("terminologies/" + terminologyId + "/terms/" , id, action, options);
    }

    delete(terminologyId, id) {
        return this.resourcesService.delete("terminologies/" + terminologyId + "/terms/" , id);
    }
}

class CatalogueUser
{
>>>>>>> 11d723a64f4499b439bd6ed5521ca4c4101a0749

    constructor(private resourcesService: ResourcesService) { }

    get(id, action, options) {
        if (!options) {
            options = {};
        }
        return this.resourcesService.get("catalogueUsers", id, action, options);
    }

    post(id, action, options) {
        return this.resourcesService.post("catalogueUsers", id, action, options);
    }
    put(id, action, options) {
        return this.resourcesService.put("catalogueUsers", id, action, options);
    }
}

class UserGroup {
    constructor(private resourcesService: ResourcesService) { }
    get(id?, action?, options?) {
        return this.resourcesService.get("userGroups", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("userGroups", id, action, options);
    }
    put(id, action, options) {
        return this.resourcesService.put("userGroups", id, action, options);
    }
    delete(id, action) {
        return this.resourcesService.delete("userGroups", id, action, null, null);
    }

}

class CatalogueItem {
    constructor(private resourcesService: ResourcesService) { }
    tree(id, includeSupersededModels) {
        id = id ? "?id=" + id : "";
        includeSupersededModels = includeSupersededModels ? "?includeSupersededModels=true" : "";
    }
    get(id, action, options) {
        return this.resourcesService.get("catalogueItems", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("catalogueItems", id, action, options);
    }
    put(id, action, childId, options) {
        if (!options) {
            options = {};
        }
        id = !id ? "" : id;
        action = !action ? "" : action + "/";
        childId = !childId ? "" : childId;
        return this.put("catalogueItems", id, action + childId, options);
    }
    delete(id, action, childId) {
        id = !id ? "" : id;
        action = !action ? "" : action + "/";
        childId = !childId ? "" : childId;
        return this.resourcesService.delete("catalogueItems", id, action + childId, null, null);//TODO check this delete method
    }
}

class Authentication {
    constructor(private resourcesService: ResourcesService) { }

    get(action) {
        return this.resourcesService.get("authentication", null, action, null);
    }
    post(action, options, more) {
        return this.resourcesService.post("authentication", null, action, options, more);
    }
}

class Tree {
    constructor(private resourcesService: ResourcesService) { }
<<<<<<< HEAD
    get(id, action, options) {
=======
    get(id?, action?, options?)
    {
>>>>>>> 11d723a64f4499b439bd6ed5521ca4c4101a0749
        return this.resourcesService.get("tree", id, action, options);
    }
};

class MetaData {
    constructor(private resourcesService: ResourcesService) { }
    namespaces: Namespaces = new Namespaces(this.resourcesService);
}

class Namespaces {
    constructor(private resourcesService: ResourcesService) { }
    get(id?, action?) {
        return this.resourcesService.get("metadata/namespaces", id, action);
    }
}

class DataModel {
    constructor(private resourcesService: ResourcesService) { }
    get(id, action?, options?) {
        if (!options) {
            options = {};
        }

        if (['metadata', 'annotations', 'classifiers', 'semanticLinks'].indexOf(action) !== -1) {
            return this.resourcesService.catalogueItem.get(id, action, options.contentType);
        }
        return this.resourcesService.get("dataModels", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("dataModels", id, action, options);
    }
}

class Facets {
    constructor(private resourcesService: ResourcesService) { }

    get(id, action, options) {
        return this.resourcesService.get("facets", id, action, options);
    }
    post(id, action, options) {
        return this.resourcesService.post("facets", id, action, options);
    }
    put(id, action, childId, options) {
        if (!options) {
            options = {};
        }
        id = !id ? "" : id;
        action = !action ? "" : action + "/";
        childId = !childId ? "" : childId;
        return this.resourcesService.put("facets", id, action + childId, options);
    }
    delete(id, action, childId) {
        id = !id ? "" : id;
        action = !action ? "" : action + "/";
        childId = !childId ? "" : childId;
        return this.resourcesService.delete("facets", id, action + childId, null, null);
    }

    attachReferenceFile(id, formData) {
        //var url = $rootScope.backendURL + "/facets/" + id + "/referenceFiles";
        //return restHandler({
        //    url: url,
        //    method: "POST",
        //    withCredentials: true,
        //    data: formData,
        //    transformRequest: function (data, headersGetterFunction) {
        //        return data;
        //    },
        //    headers: {
        //        'Content-Type': undefined
        //    }
        //});
    }

    downloadLinkReferenceFile(elementId, fileId) {
        // return $rootScope.backendURL + "/facets/" + elementId + "/referenceFiles/" + fileId;
    }

}